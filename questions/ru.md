#### Вопросы

1. [Продемонстрировать два способа создания пустого хэша](#ответ-1)
2. [Создайте хэш с двумя символами в виде клавиш, каждый из которых имеет разные строки в качестве значений](#ответ-2)
3. [Продемонстрировать, как передать ключ в хэш](#ответ-3)
4. [Что возвращается, если вы передаете ключ, который не существует в хэш?](#ответ-4)
5. [Продемонстрируйте, как изменить значение, связанное с ключом в хеше](#ответ-5)
6. [Есть ли хеширование? Имеет ли значение порядок ключей и пар?](#ответ-6)
7. [Как бы вы вернули все ключи в хеше?](#ответ-7)
8. [Эти ключи, которые возвращаются ... каков  их класс?](#ответ-8)
9. [Как определить, есть ли ключ в хеше?](#ответ-9)
10. [Как вы возвращаете все значения из хэша?](#ответ-10)
11. [Как бы вы объединили один хеш в другой хэш?](#ответ-11)
12. [Как бы вы добавили пару «ключь значение» в существующий хеш?](#ответ-12)
13. [Являются ли эти "one" ... 'one'  строками](#ответ-13)
14. [Сделайте строку с кавычками внутри строки ... несколькими способами](#ответ-14)
15. [Зачем вам использовать двойные или одинарные кавычки?](#ответ-15)
16. [Каковы некоторые общие экранируемые символы и как вы их экранируете?](#ответ-16)
17. [Как вы используете гибкие кавычки, чтобы не беспокоиться о предыдущих вещах? т. е. это отличный способ создать строку](#ответ-17)
18. [гибкие кавычки с разделителем могут использоваться для отображения множественных строк ... продемонстрируйте ...](#ответ-18)
19. [Что такое документ? описать и создать один в рубине](#ответ-19)
20. [Какой оператор будет конкатенировать 2 строки? Оставляет ли он строки без изменений?](#ответ-20)
21. [Продемонстрируйте, как конкатенировать в конец строки](#ответ-21)
22. [Что такое оператор «лопаты»(showel) и что он делает для строк?](#ответ-22)
23. [В чем разница между "+=" и "<<"?](#ответ-23)
24. [Каков результат? `"\n".size` Что такое "\t"?](#ответ-24)
25. [Можете ли вы экранировать символы в одинарных кавычках?](#ответ-25)
26. [Как вы интерполируете строку?](#ответ-26)
27. [Покажите два способа получить от 4 до 6 буквы из «One is less than two» * ruby1.9 Также рассмотрите вопрос ниже.](#ответ-27)
28. [Расскажите мне, какое есть отличие в 1.8 и 1.9 ... x = string [1], как вы получете то, что вы *обычно* хотите здесь, в 1.8](#ответ-28)
29. [Как бы вы разделили эту строку? «Один два три», что вы получите при разделении?](#ответ-29)
30. [Покажите, как вы разделили бы при помощи регулярных выражений.](#ответ-30)
31. [Используйте `split` и `join` в строках / массиве. Является ли `join` действительным для строк? Что делает `join` с массивом? что он делает с строкой?](#ответ-31)
32. [`a = "one" b = "one"` .. `a == b?` делает `a.object_id == b.object_id?` Что при «==» обычно вызывается. ](#ответ-32)
33. [Является ли `nil` объектом?](#ответ-33)
34. [`nil.nil?` возвращается?](#ответ-34)
35. [`nil.to_s` возвращается?](#ответ-35)
36. [`nil.inspect` возвращается?](#ответ-36)
37. [Опишите функцию `is_a?`](#ответ-37)
38. [`one =: symbol1` ... `two =: symbol1` ... являются ли `one` и `two` одинаковыми объектами?](#ответ-38)
39. [Обсудите имена методов и их отношение к символам](#ответ-39)
40. [Обсудить Константы и их отношения к символам](#ответ-40)
41. [Верно ли что `:symb ==:"symb"?` или `name =:"name"`](#ответ-41)
42. [Символы Ruby никогда не могут быть удалены (garbage collected)? это правда в 1.9?](#ответ-42)
43. [Как вы можете превратить строку в символ?](#ответ-43)
44. [Создайте символ, в котором есть пробелы.](#ответ-44)
45. [Создайте символ с интерполяцией](#ответ-45)
46. [Что происходит, когда вы передаете в символ интерполированную строку?](#ответ-46)
47. [Каков класс выражения Regualar Expression?](#ответ-47) 
48. [Покажите два способа, как вы можете сопоставить строку с регулярным выражением](#ответ-48)
49. [Что возвращается, когда вы получаете совпадение? А когда нет совпадений?](#ответ-49)
50. [Что следующие символы делают в Regexp?](#ответ-50)
```ruby
?
+
*
|
 []
\d # скажем «обратная косая черта d»
\s # скажем, «обратная косая черта s»
\w # обратная косая черта w
.
\A # обратная косая черта заглавная A
\Z # обратная косая черта заглавная Z vs \z
^
$
```
51. [Что такое жадное совпадение?](#ответ-51)
52. [Если совпадений более чем одно, что возвращается?](#ответ-52)
53. [как это называеться «/»? Как это называется «\»?](#ответ-53)
54. [Продемонстрируйте совпадение диапазона в Regexp](#ответ-54)
55. [Приведите пример отрицания класса символов ](#ответ-55)
56. [Как вы получаете отрицание классов characer?](#ответ-56)
57. [Как бы вы вернули группу результатов в массив?](#ответ-57)
58. [Как вы можете взять строку и вернуть массив со всеми его словами?](#ответ-58)
59. [что делает метод sub для строки?](#ответ-59)
60. [`gsub`?](#ответ-60)
61. [Обсуди глобальные методы](#ответ-61)
62. [Какую Runtime ошибка вызывается при вызове метода с неправильным количеством аргументов?](#ответ-62)
63. [Продемонстрировать, как определить метод со значениями аргументов по умолчанию](#ответ-63)
64. [Продемонстрировать, как определить метод, который принимает переменное количество аргументов](#ответ-64)
65. [Если ничего не передается в метод с переменной arg, каково значение этого аргумента в методе?](#ответ-65)
66. [Как указать возвращаемое значение в методе? что если вы не укажете возвращаемое значение?](#ответ-66)
67. [Покажите два способа вызова метода, определенного в том же классе, что и метод, который вы сейчас используете.](#ответ-67)
68. [определить приватный метод в классе](#ответ-68)
69. [расскажите, можете ли вы вызвать приватный метод из другого метода этого класса. Как вы можете его не вызвать?](#ответ-69)
70. [Как вы объявляете константу верхнего уровня? Как вы можете это сделать?](#ответ-70)
71. [Как насчет объявления констант в классе и ссылки на них?](#ответ-71)
72. [Вложенные классы наследуют константы?](#ответ-72)
73. [А как насчёт подклассов, наследуют ли они константы из родительских классов?](#ответ-73)
74. [Если Константа объявлена как в родительском классе, так и в унаследованном классе(или например во вложенном классе), который победит?](#ответ-74)
75. [Опишите статическую (лексическую) области видимости (scope) и динамическую области видимости.](#ответ-75)
76. [Какие операторы возвращают значение в Ruby?](#ответ-76)
77. [Напишите, «if then else»  в Ruby](#ответ-77)
78. [Напишите «if then else» в ruby, который присваивает значение переменной. Что делать, если результат оператора «if then» не присваивает значение? Что возвращается?](#ответ-78)
79. [Присвоить значение с помощью оператора условия](#ответ-79)
80. [Присвоить значение с помощью модификатора оператора.](#ответ-80)
81. [написать инструкцию «unless»](#ответ-81)
82. [написать инструкцию «while»](#ответ-82)
83. [написать инструкцию «break» в цикле, останавливает ли он весь цикл?](#ответ-83)
84. [Напишите «next» инструкцию](#ответ-84)
85. [написать инструкцию «for»](#ответ-85)
85b. [Все вышеперечисленное. изменяют ли они текущую область видимости? они тянут локальные переменные? если вы измените эти локальные переменные, они изменяться после инструкций «while/unles/for»?](#ответ-85b)
86. [Что оценивается как false при вводе в условных операторах?](#ответ-86)
87. [Что делает «require»? продемонстрировать его  вызов](#ответ-87)
88. [Что делают метод класса «ancestors» при вызове?](#ответ-88)
89. [Расскажи о дереве классов исключений (exception class).](#ответ-89)
90. [Напишите «rescue» условие. Должно ли быть «rescue» в контексте «begin/end»?](#ответ-90)



#### Ответы
###### ответ 1
`{} Hash.new`
###### ответ 2
`newhash = { :one => "uno", :two "dos"}`
###### ответ 3
`newhash[:one]` .... ты создаёшь хэш с помощью `{}` а вызываешь с помощью `[]`
###### ответ 4
`nil`
###### ответ 5
`newhash[:one] = "fixed"`
###### ответ 6
Они упорядочены в 1.9. Два хэша с одинаковыми парами ключей и значений будут одинаковыми
###### ответ 7
`newhash.keys`
###### ответ 8
Массив (Array) ... когда вы вызываете то что выше (пункт 7) вы получаете в ответ массив
###### ответ 9
`newhash.keys.include?("value")`
###### ответ 10
`newhash.values`
###### ответ 11
`newhash.merge!({:newvalue => 7, :another => 8})`
###### ответ 12
`newhash[:key] = value` ... или  (хуже) `newhash.merge!({:newvalue => 7})` ... без ! без изменения в оригинале
###### ответ 13
Да
###### ответ 14
`"He said \"hi\" to me"`
Символ обратного слеша \ экранирует символ кавычки " 
Или используйте одинарные кавычки `He said "hi" to me` Даже лучше! 
ИЛИ ДАЖЕ!!
 `%(this is "Quote" here!)`
###### ответ 15
 Пример `'He said "hi" to me'` и  `"I don't do that"` двойные кавычки для одинарных внутри и наоборот.
###### ответ 16
\" ... \' ... \n ... \\ .... экранируем с помощью \ (backslash)
###### ответ 17
`%(this is the string)` символ процента "%" создаёт строку. После % может стоять «(», «!», «{» это разделители.
###### ответ 18
 ```ruby
 newstring = %{It was the best of times
it was the worst of times
}
```
Это то же самое что и `"it was the best of times\nit was the worst of times\n"`
###### ответ 19
Это строковый литерал, который сохраняет пробелы, переводы строк и т. д. 
```ruby 
<<delimiter 
(делиметер должен быть на отдельной строчке)
..
.. 
<<delimiter
```
Вам надо написать newstring = <<delimiter 
....
delimiter ..... обратите внимание на знак равно = 
###### ответ 20
'+' да, оператор оставляет оригинал строк без изменений
###### ответ 21
`string1 += string2` ... добавит string2 к концовке string1
###### ответ 22
`<<` он конкатенирует строки, так же как и `+= string1 << string2`
###### ответ 23
Главная фича связанная с `+=` в том что она пересоздаёт переменную. Тогда как оператор лопаты «<<» модифицирует переменную. Если эта переменная была связанна с другой, пересозданная переменная потеряет эту связь. С оператором «<<» эта связь не потеряется.
`+=` не модифицирует строку, пересоздает новую 
`<<` модифицирует оригинал.
Пример:
```ruby
x = "one"
x2 = x 
x2.object_id == x.object_id # =>true , x2 и x будут иметь одинаковый object_id
y = "two" 
x2 << y # это сконкатенирует «y» с «x2» и изменит значение «x2». «x» связан с 
# «x2» поэтому он(х) измениться 
x2.object_id == x.object_id # => true
x2 += y
x2.object_id == x.object_id # => false , когда ты используешь += значение 
# х2 изменится только потому что "+=" пересоздаёт новый объект и связь 
# c X тереться. Значение Х не изменится
```
`<<` для МОДИФИКАЦИИ, `+=` для ПЕРЕНАЗНАЧЕНИЯ 
###### ответ 24
Результат "\n".size будет 1. "\t" Пробел табуляции.
###### ответ 25
Примерно да. Вот это сработает '\\\'' Это экранирует кавычку.
###### ответ 26
Используйте двойные кавычки и `#{}` внутри строки
Пример:
` "xxxx #{var}" `
###### ответ 27
`substring = string1[3,3]`  или  `substring = string1[3..5]`
###### ответ 28
В версии 1.8 оно вернет цифровое представление. В 1.9 вернётся символ... `****.chr` конвертирует число в символ
###### ответ 29
`newstringarray = string1.split` ... вернётся массив. `split` без аргументов будет разделять по пробелам.
###### ответ 30
`newstringarray = string1.split(/:/)` символ «:» это символ совпадение с регулярным выражением(разделитель)
###### ответ 31
`newstringarray = sting1.split` ... `newstring = array1.join(" ")` ... это выстроит строку с  " "(пробелом) между каждым элементом...
`join` вызывает метод `to_s` на каждом элементе и создаёт строку с тем что ты отправил в `join` как соединитель строки.
Возвращает строку
Невозможно вызвать метод на строке. Выкинет исключение NoMethodError. ХА!
###### ответ 32
Да ... `a == b` .... но это разные объекты ... `==` метод, определённый для строк внутри класса, очевидно
###### ответ 33
Да, `nil` это объект
###### ответ 34
`true`
###### ответ 35
""
###### ответ 36
`"nil"`
###### ответ 37
`is_a?` проверяет класс объекта. Пример: 
`:test.is_a?(Symbol)` ... вернёт `true` .. он проверяет и суперклассы И МОДУЛИ..  a mixed in module will make is_a? evaluate to true
###### ответ 38
Да. Оба "one" и "two" имеют одинаковые `object_id`.
###### ответ 39
Ну… все названия методов становятся символами. (возможно, что-то связано с тем, что есть только один... вы можете определить его снова / добавить к нему... но есть только один)
###### ответ 40
Ну... все константы становятся символами.
```ruby
RubyConstant = "Hello there"
```
###### ответ 41
да, Ruby превращает кавычки в символ
###### ответ 42
`true`
###### ответ 43
`"Stringthing".to_sym`
###### ответ 44
`x = :"this has spaces"`
###### ответ 45
`x = :"This has #{interpolation} in it"`
###### ответ 46
Интерполированная строка  конвертируется в строку а затем в символ
###### ответ 47
Regexp
###### ответ 48
1. `"this is string"[/is/]` или если задать переменную  `x[/is/]`

2. `x =~ /aaba/` ... `[/ /]` ... это вернёт `nil` а не объект MATCHDATA  ... для получения MATCHDATA используйте `.match`
###### ответ 49
1. Возвращается строка совпадения. Без совпадений возвращается `nil`

2. Вернёт позицию совпадения (число)
###### ответ 50
`?` символ до этого знака опционален `/ab?/` вернёт "ab" или "a" .... "b" это хорошо, но необязательно

`+` должен соответствовать хотя бы одному, а затем без ограничений `/ab+/` совпадёт с "ab" или "abbb"... но не с "a" ... должно быт и "b"

`*` соответствует нулю или больше совпадений. `/ab*/` совпадает с  "a" ... "ab" ... "abbbb".... `/b*/` совпадает с "b"..."bbb" 

`[]` совпадение с любым символом внутри скобок. `/[cbr]at/` совпадает с "cat", "bat", "rat", но не "zat" . 

`[]` is within a [] that starts the regexp ... this is a charactor class

`|` ... или

`\d` ... совпадение с любым числом

`\s` ... совпадение с любым пробелом

`\w` это символ слов в диапазоне `[/[a-zA-Z0-9_]+/]` ( используй `\w+` для получения слов ... просто `w` является просто символом слова)

`.`  любой символ вообще, кроме `\n` символа новой строки

`\A` соответствует началу строки

`\Z` соответствует концу строки, но не включает в себя новую строку... `\z` включает в себя новую строку

`^` соответствует началу строки (якорь) e.g. `/^\d/` находит номер, если он начинает строку. хорош для соответствия после `\n` . Обратите внимание на это и то что ниже, также совпадают, когда начало строки (или конец, как показано ниже) новая строка не должна быть вложена.

`$` соответствует концу строки (якорь) e.g. `/\d$/` находть число если оно в конце строки. Хорош для определения после `\n`
###### ответ 51
Regexp будет совападать как можно больше раз. Операторы повторения жадные 
###### ответ 52
Первое встреченное совпадение будет возвращено
###### ответ 53
Это косой чертой ... косой чертой и символом обратного слэша ...
###### ответ 54
`"this is a number 46"[/[0-9]+/]` - [0-9] это диапазон в Regexp
###### ответ 55
`"new match 78"[/[^0-9]+/]` – вернёт «new match»
###### ответ 56
Используйте прописной символ в качестве основы. \W 
*Интересная ссылка https://stackoverflow.com/questions/36497278/combining-negative-character-classes-in-regex*
###### ответ 57
`[/[a-f].+/]` как пример это вернёт все совпадения
###### ответ 58
`scan` примет регулярное выражение как параметр и возвращает массив со всеми совпадениями
`wordarray = "one two-three".scan(/\w+/)`
###### ответ 59
Возвращает копию str с первым вхождением шаблона, заменяющим второй аргумент. принимает два параметра `find, replace_with`
###### ответ 60
найти и заменить всё. Принимает два параметра `find, replace_with` `g`(global)`sub`
###### ответ 61
Глобальные методы существуют в программе за пределами класса.

"()" являются необязательными для списка параметров. Иногда отсутствие скобок приводит к двусмысленности. 
Неправильное количество аргументов не является синтаксической ошибкой, это ошибка выполнения (runtime error).
Глобальные методы, например, `puts` определены в ядре ... Ядро смешивается со всеми объектами и самим ядром.
###### ответ 62
ArgumentError
###### ответ 63
`def newmethod(a, b = :default) `
###### ответ 64
`def varargmethod(*args)` значения присваиваются слева направо, * заполняет оставшиеся.
Пример 1:
```Ruby
def func1(arg1, arg2, *other_args)
  p arg1.inspect       # => 1
  p arg2.inspect       # => 2
  p other_args.inspect # => [3, 4, 5]
end

func1(1, 2, 3, 4, 5)
```
если оператор '*' находится посередине, значения присваиваются слева направо, а затем справа налево, * заполняет остальные.
Пример 2:
```Ruby
def func2(arg1, arg2, *other_args, arg4, arg5)
  p arg1.inspect       # => 1
  p arg2.inspect       # => 2
  p other_args.inspect # => [3, 4]
  p arg4.inspect       # => 5
  p arg5.inspect       # => 6
end

func2(1, 2, 3, 4, 5, 6)
```
###### ответ 65
[]
###### ответ 66
`return :returnvalue`, если вы не укажете возвращаемое значение, возвращается значение последней выполненной операции. 

После того, как встречается возврат, метод передает управление обратно.
###### ответdd 67
`x = method_defined_in_class(3,4)` или `x = self.method_defined_in_class(3,4)` ... self подразумевается
###### ответ 68
```Ruby
def private_method(a,b)
  a*b
end

private :private_method
```
вы также можете определить методы под словом private в классе
###### ответ 69
Вы можете вызвать приватный метод внутри класса, но он не будет работать, если 
вы используете `self.private_method`
Вы получите ошибку `NoMethodError`
###### ответ 70
`CaptialLetter = "value"` 

вы можете сослаться на неё `::Capitalletter`
###### ответ 71
Объявите константу так же. Вы можете сослаться на неё так 
`ClassName::CapitalLetter` или даже `::ClassName::CapitalLetter`
###### ответ 72
Да
###### ответ 73
Да
###### ответ 74
Если у вас есть вложенный класс, который наследуется от другого класса и также 
вложен в класс, лексический область видимости победит (вложенная будет принимать
 от унаследованного (вне вложенности), а не из < родителя)
Поиск определение переменной будет сначала локально, а затем через цепочку 
наследования.
```Ruby
class ParentClass
  KONSTANTA = 'Parent Const'
end

class MainClass
  KONSTANTA = "Main Const"
  class NestedClass < ParentClass; end
end

puts MainClass::KONSTANTA               # Main Const
puts MainClass::NestedClass::KONSTANTA  # Parent Const
```
###### ответ 75
Эти примеры показывают, как Руби визуализирует лексическую статическую 
области видимости. Переменные статического области видимости привязаны локально 
... динамические переменные с областью действия будут всплывать и выходить из 
стека на основе окружения. Ruby ищет константы в этом порядке
1 Область видимости
2 Любые внешние области видимости (повторяются до достижения верхнего уровня)
3 Включенные модули
4 Суперкласс(ы)
5 Объект
6 Kernel (Ядро)
###### ответ 76
Каждый оператор возвращает значение в Ruby
###### ответ 77
```Ruby
if condition == true
  :returnval
else
  :otherval
end
```
###### ответ 78
```Ruby
value = if condition == 8
  :returnvalue
elsif condition == 9
  :othervalue
else
  :finalthing
end
```
Вы можете сказать так ... «присвойте значение, потому что ...» 
КАЖДОЕ УТВЕРЖДЕНИЕ В RUBY возвращает значение
Если вы сделаете это, и не будет совпадений... возвращается «nil».
###### ответ 79
```Ruby
value = (x == 4 ? "true_value" : "false_value")
```
###### ответ 80
```Ruby
value = 17 if x == 7 
```
###### ответ 81
```ruby
unless x == 5
  puts "here"
end
```
###### ответ 82
```ruby
while x < 5
  z + 1
  stuff = stuff - 1
end
```
###### ответ 83
```ruby
while x < 5 # И да, он останавливает весь цикл
  z + 1
  break if interupt_recieved == true
end
```
###### ответ 84
```ruby
while x < 5
  z + 1
next if interupt_recived == true # «next» проскакивает цикл
  cc + 1
end
```
###### ответ 85
```ruby
for x in arraylist
put x // «For» - это итератор, который будет проходить по каждому элементу arraylist
end 
```
###### ответ 85b
Все они будут работать в локальной среде. любые изменения в переменных будут отражены. 
All of these will pull in the local environment. any changes to vars will be reflected. Область видимости не изменяется.
###### ответ 86
`false` и `nil` ... внимание! 0 (ноль) не будет оцениваться как `false` 
###### ответ 87
Он загрузит файл во время выполнения. `require 'filename.rb'` ** обратите внимание, что он выполнит этот файл ... не просто загрузит классы и прочее... он запустит его
###### ответ 88
возвращает массив всех классов и модулей, от которых данный класс наследует.
###### ответ 89
Объект находится на вершине ... конечно же. Исключение наследуется от `Object` ... затем от `StandardError` .... и от `RuntimeError` 
###### ответ 90
```ruby
begin
    # do stuff
    # if bad stuff happens
    fail "error in this code block"
rescue StandardError => ex
    # stuff to do after the rescue
ensure
    # stuff to DEFINATLY DO 
end 
```
ну, вы конечно можете использовать `rescue "stuff to say"` ... 
Но да, если вы хотите, чтобы структура была как выше, кажется, что вы должны заключить исключение в блока «`begin`/`end`»